# 設計問答集

## Pieceクラスのデフォルトコンストラクタを定義すべきか
- `Piece` は `PieceType (enum)` と `PlayerSide (enum)` をメンバに持つ。
- 意味のない駒（不正な初期状態）を生成したくないためデフォルト構築を禁じたいという動機。
- しかし、`Piece` をメンバに持つ構造体やクラスの初期化が煩雑になる。
- 結論: デフォルトコンストラクタを用意して運用し、デフォルト値から変更されないことによる不具合が出た段階で再検討する。

## 駒の動きの種類
- 駒を動かす
- 駒を取る
- 駒を成る
- 駒を打つ

## Move構造体の定義配置 (MoveManager.h に含めるべきか)
- 他クラスが `Move` 構造体だけ必要な場合に `MoveManager` まで読み込むのは無駄。
- 方針: まず `Move.h` として独立。後で統合可能なタイミングが来たら再配置を検討。

## std::move 使用判断
- まだ習熟不足と認識。
- （運用メモ）右辺値化の目的: 所有権移動 / コピー回避。不要な場面で付けない癖づけ、戻り値最適化に過信しすぎない。

## vector と array の使い分け
- 要素数が固定でサイズ変更不要 → `std::array`
- 可変長 / 要素追加・削除など柔軟性が必要 → `std::vector`


## テストプロジェクトを含めたときのフォルダ構成

### 設計要件
1. **テストの即時実行性**: アプリ本体とテストを別ソリューションに分けず、同一ソリューション内で管理。
2. **ビルドの明確な分離**: テストプロジェクトのビルドが本体のビルド成果物を汚染しない。
3. **GoogleTest の制約回避**: GoogleTest は Debug/Release 構成のみサポート。独自のビルド構成追加は避ける。

### 採用方針: codetop / testtop プロジェクト方式
- **単一ソリューション構成**: `Shoryu.sln` にすべてのプロジェクトを含める。
- **codetop プロジェクト**: 
  - 空のプロジェクト (ソースコード・エントリポイントなし)。
  - アプリ本体に必要なプロジェクトへの依存関係のみを定義。
  - `codetop` をビルドすると、アプリ本体に必要なプロジェクト群が自動的にビルドされる。
- **testtop プロジェクト**:
  - 空のプロジェクト (ソースコード・エントリポイントなし)。
  - テスト実行に必要なプロジェクトへの依存関係のみを定義。
  - `testtop` をビルドすると、テストプロジェクト群とその依存ライブラリが自動的にビルドされる。

## ShoryuCore クラスから Game クラスへの変更

### 変更の背景
- MVC アーキテクチャの導入に伴い、Model 層の中核クラスの命名を再検討。
- `ShoryuCore` という名前は汎用的すぎて、クラスの責務が不明瞭。

### 検討した候補
1. **GameState** - 最初の候補だったが採用せず
2. **Position** - 将棋エンジンの業界標準だが、既存の `Position(suji, dan)` と名前衝突
3. **Game** - 最終的に採用 ✅

### Game を選んだ理由

#### 理由1: "State" という名前の矛盾
- `GameState` という名前は「不変 (immutable)」を連想させる
- しかし実際のクラスは可変 (mutable) であり、`getBoardMutable()` や `togglePlayer()` などの状態変更メソッドを持つ
- 名前と実装が矛盾している

#### 理由2: 不変にするコストが大きすぎる
- Board クラスだけで約 1600 バイト (9×9×16バイト)
- Hand クラス × 2 も含めると、1つのインスタンスが約 1800 バイト以上
- これを不変にすると、指し手のたびに全体をコピーする必要があり、パフォーマンスが致命的に悪化
- 将棋エンジンでは1秒間に数百万局面を評価するため、コピーコストは許容できない

#### 理由3: Model 層のトップとしての適切な抽象度
- `Game` は「将棋の1局」を表現するクラスとして、ちょうど良い粒度
- Board, Hand, MoveManager などを統合管理する役割
- Model 層の階層構造:
  ```
  Game (将棋の1局全体)
  ├── Board (9×9の盤面)
  ├── Hand (先手の持ち駒)
  ├── Hand (後手の持ち駒)
  └── MoveManager (指し手履歴)
  ```

### Game クラスの責務
- ゲーム全体の状態を統合管理する Model 層の中核クラス
- 盤面、持ち駒、手番、手数などを保持
- `GameController` (Controller 層) から操作される
- C# の View 層には直接公開せず、`GameController` 経由でアクセス

### 設計方針
- **値セマンティクス**: Board, Hand を直接所有 (ポインタではなく値として保持)
- **可変性**: パフォーマンス重視のため、状態は可変として設計
- **MVC パターン**: Model 層として、ビジネスロジックとデータを View/Controller から分離

## Controller 層の必要性と責務の分離

### 背景
- `Game` クラスは `executeMove()` と `undoLastMove()` というシンプルなAPIを持つ
- `Move` 構造体の構築方法で一手のバリエーション（通常移動、駒取り、成り、打ち）を吸収
- `getBoard()` などのゲッターは View 層でのデータ取得用
- この状況で Controller 層（`GameController`）は本当に必要なのか？

### 結論: Controller 層は必要 ✅

#### 理由1: Model 層と View 層の結合を避ける
- **現状の問題**: `Game` クラスが直接 View 層（C#）に公開されると、依存関係が密結合になる
- **理想的な構造**:
  ```
  C# View Layer
     ↓ (参照)
  C++ Controller Layer (GameController)
     ↓ (参照)
  C++ Model Layer (Game, Board, Hand...)
  ```
- **メリット**: View 層の変更（C# → 別の言語/フレームワーク）が容易になる
- **メリット**: Model 層の内部実装変更が View 層に影響しない

#### 理由2: ユーザー操作の文脈を管理する場所
- **Controller の責務**: ユーザー操作を Model の操作に変換する
- **具体例**: 
  - UIから「盤面の(7,7)をクリック → (7,6)をクリック → 成り選択ダイアログでOK」という操作列
  - これを Controller が `Move` 構造体に変換して `Game::executeMove()` を呼ぶ
- **Model には持たせるべきでない情報**:
  - 「現在選択中のマス」
  - 「成り選択中かどうか」
  - 「持ち駒選択モード中かどうか」
  - これらは UI の状態であり、ゲームの局面情報ではない

#### 理由3: 合法手生成と Move 構築の責務分離
- **`LegalMoveFinder`**: 合法手の候補（`Position` のリスト）を返す
- **Controller の役割**: 合法手候補とユーザー操作を組み合わせて `Move` 構造体を構築
- **Move 構造体の構築ロジックは Controller 層に配置するのが適切**:
  ```cpp
  // Controller 層での Move 構築例
  Move createNormalMove(Position from, Position to, const Board& board) {
      Move move;
      move.from = from;
      move.to = to;
      move.movedPieceBefore = board.getPiece(from);
      move.movedPieceAfter = move.movedPieceBefore.value();
      move.capturedPiece = board.getPiece(to);
      return move;
  }
  
  Move createDropMove(Position to, Piece piece) {
      Move move;
      move.from = std::nullopt;  // 打つ手
      move.to = to;
      move.movedPieceBefore = std::nullopt;
      move.movedPieceAfter = piece;
      move.capturedPiece = std::nullopt;
      return move;
  }
  ```

#### 理由4: 入力検証とエラーハンドリング
- **Controller の責務**: ユーザー入力の妥当性検証
  - 選択した駒が現在のプレイヤーの駒か？
  - 選択した移動先が合法手リストに含まれるか？
  - 二歩のチェック（持ち駒の歩を打つ場合）
- **Model の責務**: 内部状態の一貫性を保つ
  - `executeMove()` は与えられた `Move` が正しい前提で実行する
  - 不正な `Move` の検証は Controller が事前に行う

#### 理由5: トランザクション的な操作の管理
- **将来の拡張例**: 「待った（複数手戻す）」機能
  ```cpp
  // Controller 層
  void GameController::undoMultipleMoves(int count) {
      for (int i = 0; i < count; ++i) {
          if (!canUndo()) break;
          game_.undoLastMove();
      }
  }
  ```
- **将来の拡張例**: 「棋譜の読み込み」機能
  ```cpp
  // Controller 層
  void GameController::loadKifu(const std::vector<Move>& moves) {
      game_.clear();
      game_.initializeStartPosition();
      for (const auto& move : moves) {
          game_.executeMove(move);
      }
  }
  ```

### GameController の設計指針
1. **状態変換の責務**: UI状態 → Model操作の変換を担当
2. **Move 構築の責務**: `Position` や駒種類から `Move` 構造体を構築
3. **検証の責務**: ユーザー入力の妥当性を確認（Model 呼び出し前）
4. **View インターフェース**: View 層に必要な情報を整形して提供
5. **高レベル操作**: 複数の Model 操作を組み合わせた機能を提供

### まとめ
- `Game` クラスがシンプルなAPIを持つのは正しい設計
- しかし、だからこそ Controller 層が必要
- Controller は「操作のバリエーション」と「ユーザー文脈」を管理する
- `createMove` 関数やクラスは Controller 層に配置するのが適切
- Model はシンプルに保ち、複雑さは Controller が吸収する

## Move 構築ヘルパー関数を3つに分ける設計

### 背景
- `Move` 構造体はすべてのメンバを受け取る汎用的な `createMove` 関数1つでも実現可能
- しかし、`GameController` では3つの専用関数に分けている：
  - `createNormalMove(Position from, Position to)`
  - `createPromotionMove(Position from, Position to)`
  - `createDropMove(Position to, PieceType pieceType)`

### 結論: 3つに分けるべき ✅

#### 理由1: 意図の明確さ
```cpp
// 3つの関数 - 意図が一目瞭然
auto move1 = controller.createNormalMove(from, to);
auto move2 = controller.createPromotionMove(from, to);
auto move3 = controller.createDropMove(to, PieceType::Fu);

// 1つの汎用関数 - 何をしているのか分かりにくい
auto move1 = controller.createMove(from, to, piece, piece, capturedPiece);
auto move2 = controller.createMove(from, to, piece, promotedPiece, capturedPiece);
auto move3 = controller.createMove(std::nullopt, to, std::nullopt, droppedPiece, std::nullopt);
```

#### 理由2: 必要な情報だけを要求
```cpp
// 打つ手には「from」は不要 - シンプル
createDropMove(to, pieceType);

// vs 汎用関数 - 不要な nullopt を渡す冗長性
createMove(std::nullopt, to, std::nullopt, piece, std::nullopt);
```

#### 理由3: エラーの防止
- **3つの関数**: 型システムで間違った組み合わせを渡せない
- **1つの汎用関数**: 不正な組み合わせ（例: `from` が `nullopt` で `movedPieceBefore` に値がある）を渡せてしまう

#### 理由4: 実装の詳細を隠蔽
Controller層が「盤面を見て自動的に情報を補完する」責務を持つ：

```cpp
Move createNormalMove(Position from, Position to) const {
    return Move{
        .from = from,
        .to = to,
        .capturedPiece = game_.getBoard().getPiece(to),      // 自動取得
        .movedPieceBefore = game_.getBoard().getPiece(from), // 自動取得
        .movedPieceAfter = game_.getBoard().getPiece(from).value()
    };
}
```

**View層の利点**: `from` と `to` だけ知っていればよく、盤面の状態を意識する必要がない

### 将棋の指し手は3パターンで完全にカバーできる

| 操作 | 使う関数 | 備考 |
|------|---------|------|
| 移動だけ | `createNormalMove` | `capturedPiece` は `nullopt` |
| 移動して取る | `createNormalMove` | `capturedPiece` に駒が入る（自動判定） |
| 移動して成る | `createPromotionMove` | `capturedPiece` は `nullopt` |
| 移動して取って成る | `createPromotionMove` | `capturedPiece` に駒が入る（自動判定） |
| 持ち駒を打つ | `createDropMove` | `from` が `nullopt` |

**重要**: 「駒を取る」は独立した操作ではなく、移動先に駒があるかどうかで自動的に判定される

### まとめ
- 3つの関数で将棋のすべての指し手パターンをカバーできる
- 汎用関数1つよりも、意図が明確で型安全
- Controller層の責務（盤面情報の自動補完）を適切に表現
- View層は最小限の情報だけを提供すればよい

## std::optional のアクセス方法: value() vs *

### 背景
- `std::optional` から値を取り出す方法は2つある：
  - `opt.value()` - 値がなければ `std::bad_optional_access` 例外を投げる
  - `*opt` - 値がなければ未定義動作（ポインタと同じ）

### 結論: `*` で統一すべき ✅

#### 理由1: 統一性とシンプルさ
```cpp
// ❌ 不統一 - 可読性が低い
if (opt) {
    use(opt.value());  // 8文字
}

// ✅ 統一 - 簡潔で可読性が高い
if (opt) {
    use(*opt);  // 1文字
}
```

#### 理由2: ポインタとの一貫性
```cpp
std::optional<T> opt;
T* ptr;

// 同じパターン
if (opt) { use(*opt); }
if (ptr) { use(*ptr); }
```

#### 理由3: パフォーマンス
- `*opt` は事前に `if (opt)` でチェック済みなら高速で安全
- `opt.value()` は内部で存在チェックを行い、例外を投げる可能性がある（オーバーヘッド）

#### 理由4: 前提条件の明確化
```cpp
// 前提条件: opt に値が存在する（呼び出し側が保証）
if (opt) {
    const auto& value = *opt;  // 前提条件が満たされている
    // ...
}
```

### コードベース全体での統一パターン

```cpp
// ✅ 推奨パターン
if (auto piece = board.getPiece(pos)) {
    use(*piece);
}

// または
auto maybePiece = board.getPiece(pos);
if (maybePiece) {
    use(*maybePiece);
}

// ❌ 避けるべきパターン
if (auto piece = board.getPiece(pos)) {
    use(piece.value());  // 冗長
}
```

### デバッグビルドでの保護（オプション）

必要に応じて `assert` で前提条件を文書化：

```cpp
auto opt = board.getPiece(pos);
assert(opt.has_value() && "Precondition: piece must exist");
const auto& piece = *opt;
```

- **Debug ビルド**: 前提条件違反で即座に停止 → バグの早期発見
- **Release ビルド**: `assert` が消えて最高のパフォーマンス

### まとめ
- `*opt` で統一することで、コードが簡潔で一貫性のあるものになる
- 事前に存在チェックを行う設計により、安全性とパフォーマンスを両立
- ポインタとの一貫性により、C++ のイディオムに従った自然なコード

## 契約による設計: createMove 関数の前提条件

### 背景
- `createNormalMove(from, to)` は `from` に駒が存在することを前提とする
- この前提条件をどこで保証すべきか？

### 結論: 呼び出し側が前提条件を保証すべき ✅

#### 契約による設計 (Design by Contract)

**前提条件 (Precondition)**: 呼び出し側が満たすべき条件
- `createNormalMove()` の前提: `from` に駒が存在する

**事後条件 (Postcondition)**: 関数が保証する条件
- `createNormalMove()` は有効な `Move` を返す

#### 実装例

```cpp
// ✅ Controller 層 - 前提条件を信頼
Move GameController::createNormalMove(Position from, Position to) const
{
    // 前提: from に駒が存在する（呼び出し側が保証）
    return Move{
        .from = from,
        .to = to,
        .capturedPiece = game_.getBoard().getPiece(to),
        .movedPieceBefore = game_.getBoard().getPiece(from),
        .movedPieceAfter = *game_.getBoard().getPiece(from)  // ✅ * で直接アクセス
    };
}

// ✅ View 層または上位 Controller - 前提条件を保証
void handleUserClick(Position clickedPos)
{
    // 事前チェック
    auto piece = controller.getBoard().getPiece(clickedPos);
    if (!piece) {
        return;  // 駒がない → 何もしない
    }

    // または合法手チェック
    auto legalMoves = controller.getLegalMoves(clickedPos);
    if (legalMoves.empty()) {
        return;  // 動けない駒
    }

    // ここまで来たら clickedPos に駒が存在することが保証される
    Move move = controller.createNormalMove(clickedPos, destination);
    controller.executeMove(move);
}
```

#### 防御的プログラミング vs 契約

**❌ 防御的プログラミング（過剰）**:
```cpp
Move createNormalMove(Position from, Position to) const
{
    auto piece = game_.getBoard().getPiece(from);
    if (!piece) {
        throw std::invalid_argument("No piece at from");  // 冗長なチェック
    }
    // ...
}
```

**問題点**:
- パフォーマンスの低下（毎回チェック）
- 責務の混乱（誰がチェックすべきか不明確）
- エラー処理が複雑化

**✅ 契約による設計（推奨）**:
```cpp
Move createNormalMove(Position from, Position to) const
{
    // 前提: from に駒が存在する（呼び出し側が保証）
    return Move{
        .movedPieceAfter = *game_.getBoard().getPiece(from)  // シンプル
    };
}
```

**利点**:
- 高速（余計なチェックなし）
- 責務が明確（呼び出し側がチェック）
- コードがシンプル

#### デバッグサポート（オプション）

```cpp
Move createNormalMove(Position from, Position to) const
{
    assert(game_.getBoard().getPiece(from).has_value() 
           && "Precondition: piece must exist at from");
    
    return Move{
        .movedPieceAfter = *game_.getBoard().getPiece(from)
    };
}
```

- **Debug ビルド**: 前提条件違反で即座に停止
- **Release ビルド**: `assert` が消えて最高速

### 責務の分離

| 層 | 責務 |
|----|------|
| **View / 上位 Controller** | 前提条件の保証（駒の存在チェック、合法手チェック） |
| **GameController** | 前提条件を信頼して Move を構築 |
| **Game / Model** | 与えられた Move が正しい前提で実行 |

### まとめ
- 呼び出し側が前提条件を保証する設計
- Controller 層は前提条件を信頼してシンプルに実装
- `*opt` で直接アクセスすることで、コードが簡潔で高速
- デバッグビルドでの `assert` により、前提条件違反を早期発見