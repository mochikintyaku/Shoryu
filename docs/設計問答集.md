# 設計問答集

## なぜ Core を C++ で書いて、GUI を C# にしたのか？

### Q. すべて C# で書かず、わざわざ Core を C++ で書いた理由は？

A. C++ での設計・デザインパターン習得を主目的とした「実践テーマ」にしたかったため。

- 学習目的
  - C++ でデザインパターンや設計を勉強している
  - その題材として将棋の Core ロジックを C++ でしっかり設計・実装したい
- 技術的な副次効果
  - 値型・RAII・`std::optional` など、C++ ならではの設計を活かせる
  - 将来的にエンジン寄りに拡張したくなったときにも対応しやすい

### Q. なぜ GUI は C# にした？ C++ で GUI を書かなかった理由は？

A. C++ の GUI 技術選定が難しく、無料で使いやすい C# を採用したため。

- C++ 側の事情
  - MFC は古く、これから新規で触るには重い
  - モダンな C++ GUI ライブラリは有償のものも多く、選択が難しい
- C# 側の利点
  - WinForms / WPF など GUI フレームワークが標準で充実
  - 無料かつ .NET と Visual Studio との親和性が高い
  - 「なんとなく C++ と連携できそう」という期待があった（具体的な方法は当初は未調査）

結果として、

- **Core**: C++20 でドメインロジック・設計パターンの実験場
- **GUI**: C# で素早く画面を組む

という役割分担に落ち着いた。

### Q. C# と C++ はどうやって連携している？ なぜ C++/CLI？

A. このプロジェクトは Windows 前提であり、既に C++ のクラス設計＋STL を使っていたため、C++/CLI をブリッジに選択した。

- 連携方法の候補
  - P/Invoke (`DllImport`) + C スタイル API
  - C++/CLI でネイティブ C++ をラップして .NET から参照
- P/Invoke を採用しなかった理由
  - `Board`, `Game`, `GameController`, `Piece` など C++ クラスと STL（`std::vector`, `std::optional`, `std::map`）を多用している
  - それらをすべて C API（`extern "C"` 関数 + POD 構造体）に落とし込むのは手間が大きい
- C++/CLI を採用した理由
  - プロジェクトは実質 Windows 前提であり、クロスプラットフォーム制約がない
  - 既存の C++ クラス設計をほぼそのまま使い、ラッパー層だけ C++/CLI で書けばよい
  - C# からは C++/CLI の `ref class`（例: `GameControllerWrapper`）だけ見ればよく、Core の詳細は隠蔽できる

---

## Pieceクラスのデフォルトコンストラクタを定義すべきか
- `Piece` は `PieceType (enum)` と `PlayerSide (enum)` をメンバに持つ。
- 意味のない駒（不正な初期状態）を生成したくないためデフォルト構築を禁じたいという動機。
- しかし、`Piece` をメンバに持つ構造体やクラスの初期化が煩雑になる。
- 結論: デフォルトコンストラクタを用意して運用し、デフォルト値から変更されないことによる不具合が出た段階で再検討する。

## 駒の動きの種類
- 駒を動かす
- 駒を取る
- 駒を成る
- 駒を打つ

## Move構造体の定義配置 (MoveManager.h に含めるべきか)
- 他クラスが `Move` 構造体だけ必要な場合に `MoveManager` まで読み込むのは無駄。
- 方針: まず `Move.h` として独立。後で統合可能なタイミングが来たら再配置を検討。

## std::move 使用判断
- まだ習熟不足と認識。
- （運用メモ）右辺値化の目的: 所有権移動 / コピー回避。不要な場面で付けない癖づけ、戻り値最適化に過信しすぎない。

## vector と array の使い分け
- 要素数が固定でサイズ変更不要 → `std::array`
- 可変長 / 要素追加・削除など柔軟性が必要 → `std::vector`

## テストプロジェクトを含めたときのフォルダ構成

### 設計要件
1. **テストの即時実行性**: アプリ本体とテストを別ソリューションに分けず、同一ソリューション内で管理。
2. **ビルドの明確な分離**: テストプロジェクトのビルドが本体のビルド成果物を汚染しない。
3. **GoogleTest の制約回避**: GoogleTest は Debug/Release 構成のみサポート。独自のビルド構成追加は避ける。

### 採用方針: codetop / testtop プロジェクト方式
- **単一ソリューション構成**: `Shoryu.sln` にすべてのプロジェクトを含める。
- **codetop プロジェクト**: 
  - 空のプロジェクト (ソースコード・エントリポイントなし)。
  - アプリ本体に必要なプロジェクトへの依存関係のみを定義。
  - `codetop` をビルドすると、アプリ本体に必要なプロジェクト群が自動的にビルドされる。
- **testtop プロジェクト**:
  - 空のプロジェクト (ソースコード・エントリポイントなし)。
  - テスト実行に必要なプロジェクトへの依存関係のみを定義。
  - `testtop` をビルドすると、テストプロジェクト群とその依存ライブラリが自動的にビルドされる。

## ShoryuCore クラスから Game クラスへの変更

### 変更の背景
- MVC アーキテクチャの導入に伴い、Model 層の中核クラスの命名を再検討。
- `ShoryuCore` という名前は汎用的すぎて、クラスの責務が不明瞭。

### 検討した候補
1. **GameState** - 最初の候補だったが採用せず
2. **Position** - 将棋エンジンの業界標準だが、既存の `Position(suji, dan)` と名前衝突
3. **Game** - 最終的に採用 ✅

### Game を選んだ理由

#### 理由1: "State" という名前の矛盾
- `GameState` という名前は「不変 (immutable)」を連想させる
- しかし実際のクラスは可変 (mutable) であり、`getBoardMutable()` や `togglePlayer()` などの状態変更メソッドを持つ
- 名前と実装が矛盾している

#### 理由2: 不変にするコストが大きすぎる
- Board クラスだけで約 1600 バイト (9×9×16バイト)
- Hand クラス × 2 も含めると、1つのインスタンスが約 1800 バイト以上
- これを不変にすると、指し手のたびに全体をコピーする必要があり、パフォーマンスが致命的に悪化
- 将棋エンジンでは1秒間に数百万局面を評価するため、コピーコストは許容できない

#### 理由3: Model 層のトップとしての適切な抽象度
- `Game` は「将棋の1局」を表現するクラスとして、ちょうど良い粒度
- Board, Hand, MoveManager などを統合管理する役割
- Model 層の階層構造:
  ```
  Game (将棋の1局全体)
  ├── Board (9×9の盤面)
  ├── Hand (先手の持ち駒)
  ├── Hand (後手の持ち駒)
  └── MoveManager (指し手履歴)
  ```

### Game クラスの責務
- ゲーム全体の状態を統合管理する Model 層の中核クラス
- 盤面、持ち駒、手番、手数などを保持
- `GameController` (Controller 層) から操作される
- C# の View 層には直接公開せず、`GameController` 経由でアクセス

### 設計方針
- **値セマンティクス**: Board, Hand を直接所有 (ポインタではなく値として保持)
- **可変性**: パフォーマンス重視のため、状態は可変として設計
- **MVC パターン**: Model 層として、ビジネスロジックとデータを View/Controller から分離

## Controller 層の必要性と責務の分離

### 背景
- `Game` クラスは `executeMove()` と `undoLastMove()` というシンプルなAPIを持つ
- `Move` 構造体の構築方法で一手のバリエーション（通常移動、駒取り、成り、打ち）を吸収
- `getBoard()` などのゲッターは View 層でのデータ取得用
- この状況で Controller 層（`GameController`）は本当に必要なのか？

### 結論: Controller 層は必要 ✅

#### 理由1: Model 層と View 層の結合を避ける
- **現状の問題**: `Game` クラスが直接 View 層（C#）に公開されると、依存関係が密結合になる
- **理想的な構造**:
  ```
  C# View Layer
     ↓ (参照)
  C++ Controller Layer (GameController)
     ↓ (参照)
  C++ Model Layer (Game, Board, Hand...)
  ```
- **メリット**: View 層の変更（C# → 別の言語/フレームワーク）が容易になる
- **メリット**: Model 層の内部実装変更が View 層に影響しない

#### 理由2: ユーザー操作の文脈を管理する場所
- **Controller の責務**: ユーザー操作を Model の操作に変換する
- **具体例**: 
  - UIから「盤面の(7,7)をクリック → (7,6)をクリック → 成り選択ダイアログでOK」という操作列
  - これを Controller が `Move` 構造体に変換して `Game::executeMove()` を呼ぶ
- **Model には持たせるべきでない情報**:
  - 「現在選択中のマス」
  - 「成り選択中かどうか」
  - 「持ち駒選択モード中かどうか」
  - これらは UI の状態であり、ゲームの局面情報ではない

#### 理由3: 合法手生成と Move 構築の責務分離
- **`LegalMoveFinder`**: 合法手の候補（`Position` のリスト）を返す
- **Controller の役割**: 合法手候補とユーザー操作を組み合わせて `Move` 構造体を構築
- **Move 構造体の構築ロジックは Controller 層に配置するのが適切**:
  ```cpp
  // Controller 層での Move 構築例
  Move createNormalMove(Position from, Position to, const Board& board) {
      Move move;
      move.from = from;
      move.to = to;
      move.movedPieceBefore = board.getPiece(from);
      move.movedPieceAfter = move.movedPieceBefore.value();
      move.capturedPiece = board.getPiece(to);
      return move;
  }
  
  Move createDropMove(Position to, Piece piece) {
      Move move;
      move.from = std::nullopt;  // 打つ手
      move.to = to;
      move.movedPieceBefore = std::nullopt;
      move.movedPieceAfter = piece;
      move.capturedPiece = std::nullopt;
      return move;
  }
  ```

#### 理由4: 入力検証とエラーハンドリング
- **Controller の責務**: ユーザー入力の妥当性検証
  - 選択した駒が現在のプレイヤーの駒か？
  - 選択した移動先が合法手リストに含まれるか？
  - 二歩のチェック（持ち駒の歩を打つ場合）
- **Model の責務**: 内部状態の一貫性を保つ
  - `executeMove()` は与えられた `Move` が正しい前提で実行する
  - 不正な `Move` の検証は Controller が事前に行う

#### 理由5: トランザクション的な操作の管理
- **将来の拡張例**: 「待った（複数手戻す）」機能
  ```cpp
  // Controller 層
  void GameController::undoMultipleMoves(int count) {
      for (int i = 0; i < count; ++i) {
          if (!canUndo()) break;
          game_.undoLastMove();
      }
  }
  ```
- **将来の拡張例**: 「棋譜の読み込み」機能
  ```cpp
  // Controller 層
  void GameController::loadKifu(const std::vector<Move>& moves) {
      game_.clear();
      game_.initializeStartPosition();
      for (const auto& move : moves) {
          game_.executeMove(move);
      }
  }
  ```

### GameController の設計指針
1. **状態変換の責務**: UI状態 → Model操作の変換を担当
2. **Move 構築の責務**: `Position` や駒種類から `Move` 構造体を構築
3. **検証の責務**: ユーザー入力の妥当性を確認（Model 呼び出し前）
4. **View インターフェース**: View 層に必要な情報を整形して提供
5. **高レベル操作**: 複数の Model 操作を組み合わせた機能を提供

### まとめ
- `Game` クラスがシンプルなAPIを持つのは正しい設計
- しかし、だからこそ Controller 層が必要
- Controller は「操作のバリエーション」と「ユーザー文脈」を管理する
- `createMove` 関数やクラスは Controller 層に配置するのが適切
- Model はシンプルに保ち、複雑さは Controller が吸収する

## Move 構築ヘルパー関数を3つに分ける設計

### 背景
- `Move` 構造体はすべてのメンバを受け取る汎用的な `createMove` 関数1つでも実現可能
- しかし、`GameController` では3つの専用関数に分けている：
  - `createNormalMove(Position from, Position to)`
  - `createPromotionMove(Position from, Position to)`
  - `createDropMove(Position to, PieceType pieceType)`

### 結論: 3つに分けるべき ✅

#### 理由1: 意図の明確さ
```cpp
// 3つの関数 - 意図が一目瞭然
auto move1 = controller.createNormalMove(from, to);
auto move2 = controller.createPromotionMove(from, to);
auto move3 = controller.createDropMove(to, PieceType::Fu);

// 1つの汎用関数 - 何をしているのか分かりにくい
auto move1 = controller.createMove(from, to, piece, piece, capturedPiece);
auto move2 = controller.createMove(from, to, piece, promotedPiece, capturedPiece);
auto move3 = controller.createMove(std::nullopt, to, std::nullopt, droppedPiece, std::nullopt);
```

#### 理由2: 必要な情報だけを要求
```cpp
// 打つ手には「from」は不要 - シンプル
createDropMove(to, pieceType);

// vs 汎用関数 - 不要な std::nullopt を渡す冗長性
createMove(std::nullopt, to, std::nullopt, piece, std::nullopt);
```

#### 理由3: エラーの防止
- **3つの関数**: 型システムで間違った組み合わせを渡せない
- **1つの汎用関数**: 不正な組み合わせ（例: `from` が `std::nullopt` で `movedPieceBefore` に値がある）を渡せてしまう

#### 理由4: 実装の詳細を隠蔽
Controller層が「盤面を見て自動的に情報を補完する」責務を持つ：

```cpp
Move createNormalMove(Position from, Position to) const {
    return Move{
        .from = from,
        .to = to,
        .capturedPiece = game_.getBoard().getPiece(to),      // 自動取得
        .movedPieceBefore = game_.getBoard().getPiece(from), // 自動取得
        .movedPieceAfter = game_.getBoard().getPiece(from).value()
    };
}

Move createDropMove(Position to, Piece piece) const {
    return Move{
        .from = std::nullopt,
        .to = to,
        .movedPieceBefore = std::nullopt,
        .movedPieceAfter = piece,
        .capturedPiece = std::nullopt
    };
}
```

**View層の利点**: `from` と `to` だけ知っていればよく、盤面の状態を意識する必要がない

### 将棋の指し手は3パターンで完全にカバーできる

| 操作 | 使う関数 | 備考 |
|------|---------|------|
| 移動だけ | `createNormalMove` | `capturedPiece` は `std::nullopt` |
| 移動して取る | `createNormalMove` | `capturedPiece` に駒が入る（自動判定） |
| 移動して成る | `createPromotionMove` | `capturedPiece` は `std::nullopt` |
| 移動して取って成る | `createPromotionMove` | `capturedPiece` に駒が入る（自動判定） |
| 持ち駒を打つ | `createDropMove` | `from` が `std::nullopt` |

**重要**: 「駒を取る」は独立した操作ではなく、移動先に駒があるかどうかで自動的に判定される

### まとめ
- 3つの関数で将棋のすべての指し手パターンをカバーできる
- 汎用関数1つよりも、意図が明確で型安全
- Controller層の責務（盤面情報の自動補完）を適切に表現
- View層は最小限の情報だけを提供すればよい

## std::optional のアクセス方法: value() vs *

### 背景
- `std::optional` から値を取り出す方法は2つある：
  - `opt.value()` - 値がなければ `std::bad_optional_access` 例外を投げる
  - `*opt` - 値がなければ未定義動作（ポインタと同じ）

### 結論: `*` で統一すべき ✅

#### 理由1: 統一性とシンプルさ
```cpp
// ❌ 不統一 - 可読性が低い
if (opt) {
    use(opt.value());  // 8文字
}

// ✅ 統一 - 簡潔で可読性が高い
if (opt) {
    use(*opt);  // 1文字
}
```

#### 理由2: ポインタとの一貫性
```cpp
std::optional<T> opt;
T* ptr;

// 同じパターン
if (opt) { use(*opt); }
if (ptr) { use(*ptr); }
```

#### 理由3: パフォーマンス
- `*opt` は事前に `if (opt)` でチェック済みなら高速で安全
- `opt.value()` は内部で存在チェックを行い、例外を投げる可能性がある（オーバーヘッド）

#### 理由4: 前提条件の明確化
```cpp
// 前提条件: opt に値が存在する（呼び出し側が保証）
if (opt) {
    const auto& value = *opt;  // 前提条件が満たされている
    // ...
}
```

### コードベース全体での統一パターン

```cpp
// ✅ 推奨パターン
if (auto piece = board.getPiece(pos)) {
    use(*piece);
}

// または
auto maybePiece = board.getPiece(pos);
if (maybePiece) {
    use(*maybePiece);
}

// ❌ 避けるべきパターン
if (auto piece = board.getPiece(pos)) {
    use(piece.value());  // 冗長
}
```

### デバッグビルドでの保護（オプション）

必要に応じて `assert` で前提条件を文書化：

```cpp
auto opt = board.getPiece(pos);
assert(opt.has_value() && "Precondition: piece must exist");
const auto& piece = *opt;
```

- **Debug ビルド**: 前提条件違反で即座に停止 → バグの早期発見
- **Release ビルド**: `assert` が消えて最高のパフォーマンス

### まとめ
- `*opt` で統一することで、コードが簡潔で一貫性のあるものになる
- 事前に存在チェックを行う設計により、安全性とパフォーマンスを両立
- ポインタとの一貫性により、C++ のイディオムに従った自然なコード

## 契約による設計: createMove 関数の前提条件

### 背景
- `createNormalMove(from, to)` は `from` に駒が存在することを前提とする
- この前提条件をどこで保証すべきか？

### 結論: 呼び出し側が前提条件を保証すべき ✅

#### 契約による設計 (Design by Contract)

**前提条件 (Precondition)**: 呼び出し側が満たすべき条件
- `createNormalMove()` の前提: `from` に駒が存在する

**事後条件 (Postcondition)**: 関数が保証する条件
- `createNormalMove()` は有効な `Move` を返す

#### 実装例

```cpp
// ✅ Controller 層 - 前提条件を信頼
Move GameController::createNormalMove(Position from, Position to) const
{
    // 前提: from に駒が存在する（呼び出し側が保証）
    return Move{
        .from = from,
        .to = to,
        .capturedPiece = game_.getBoard().getPiece(to),
        .movedPieceBefore = game_.getBoard().getPiece(from),
        .movedPieceAfter = *game_.getBoard().getPiece(from)  // ✅ * で直接アクセス
    };
}

// ✅ View 層または上位 Controller - 前提条件を保証
void handleUserClick(Position clickedPos)
{
    // 事前チェック
    auto piece = controller.getBoard().getPiece(clickedPos);
    if (!piece) {
        return;  // 駒がない → 何もしない
    }

    // または合法手チェック
    auto legalMoves = controller.getLegalMoves(clickedPos);
    if (legalMoves.empty()) {
        return;  // 動けない駒
    }

    // ここまで来たら clickedPos に駒が存在することが保証される
    Move move = controller.createNormalMove(clickedPos, destination);
    controller.executeMove(move);
}
```

#### 防御的プログラミング vs 契約

**❌ 防御的プログラミング（過剰）**:
```cpp
Move createNormalMove(Position from, Position to) const
{
    auto piece = game_.getBoard().getPiece(from);
    if (!piece) {
        throw std::invalid_argument("No piece at from");  // 冗長なチェック
    }
    // ...
}
```

**問題点**:
- パフォーマンスの低下（毎回チェック）
- 責務の混乱（誰がチェックすべきか不明確）
- エラー処理が複雑化

**✅ 契約による設計（推奨）**:
```cpp
Move createNormalMove(Position from, Position to) const
{
    // 前提: from に駒が存在する（呼び出し側が保証）
    return Move{
        .movedPieceAfter = *game_.getBoard().getPiece(from)  // シンプル
    };
}
```

**利点**:
- 高速（余計なチェックなし）
- 責務が明確（呼び出し側がチェック）
- コードがシンプル

#### デバッグサポート（オプション）

```cpp
Move createNormalMove(Position from, Position to) const
{
    assert(game_.getBoard().getPiece(from).has_value() 
           && "Precondition: piece must exist at from");
    
    return Move{
        .movedPieceAfter = *game_.getBoard().getPiece(from)
    };
}
```

- **Debug ビルド**: 前提条件違反で即座に停止
- **Release ビルド**: `assert` が消えて最高速

### 責務の分離

| 層 | 責務 |
|----|------|
| **View / 上位 Controller** | 前提条件の保証（駒の存在チェック、合法手チェック） |
| **GameController** | 前提条件を信頼して Move を構築 |
| **Game / Model** | 与えられた Move が正しい前提で実行 |

### まとめ
- 呼び出し側が前提条件を保証する設計
- Controller 層は前提条件を信頼してシンプルに実装
- `*opt` で直接アクセスすることで、コードが簡潔で高速
- デバッグビルドでの `assert` により、前提条件違反を早期発見

## Board / Hand / View 向け DTO の設計

### Q. Board は GUI にそのまま公開すべき？

A. いいえ。GUI からは `Board` 型を直接触らせず、`GameController` 経由で「表示に必要なデータだけ」を返すのがおすすめ。

- モデル層: `Board`, `Hand`, `Piece`, `Game` などのドメインモデルだけを知る
- アプリ層(View): `GameController` と DTO（View 用の単純な構造体）だけを知る
- DLL の公開面も `GameController` + DTO に絞られ、内部実装を差し替えやすくなる

### Q. DTO(Data Transfer Object) とは？

A. 処理ロジックをほとんど持たない「データを運ぶための構造体・クラス」。

- 基本は public フィールドのみ、もしくはごく薄い getter 程度
- ドメインモデル(`Board`, `Game`)とは別に、「表示や転送にちょうどよい形」に成形されたデータ
- 例: View 用の `ViewPiece` や、持ち駒一覧を表す `ViewHand` など

### Q. DTO への変換はどの層で行う？

A. **GameController (Controller 層) の責務** です。

**理由**:
- Model 層（`Board`, `Hand`）は View 層の DTO（`ViewPiece`, `ViewHand`）を知るべきではない
- Controller 層が Model と View の間のデータ変換を担当する
- Model 層の純粋性を保ち、再利用性を高める

**依存関係の方向**:
```
View 層 (C#)
   ↓ (参照)
Controller 層 (GameController) ← DTO 変換はここ
   ↓ (参照)
Model 層 (Game, Board, Hand)  ← DTO を知らない
```

**実装例**:
```cpp
// GameController.h
class GameController {
public:
    ViewBoardLayout getBoardView() const;
    ViewHand getSenteHandView() const;
    ViewHand getGoteHandView() const;
    
private:
    Game game_;
    
    // ヘルパー関数
    ViewPiece toViewPiece(const std::optional<Piece>& piece) const;
};

// GameController.cpp
ViewPiece GameController::toViewPiece(const std::optional<Piece>& piece) const
{
    if (!piece) {
        return ViewPiece{ .hasPiece = false };
    }
    
    return ViewPiece{
        .hasPiece = true,
        .owner = piece->owner(),
        .pieceType = piece->pieceType()
    };
}

ViewBoardLayout GameController::getBoardView() const
{
    ViewBoardLayout viewLayout;
    const auto& board = game_.getBoard();
    
    for (int dan = 1; dan <= BoardSize; ++dan) {
        for (int suji = 1; suji <= BoardSize; ++suji) {
            Position pos(suji, dan);
            auto piece = board.getPiece(pos);
            
            int rowIdx = Board::DanToRowIndex(dan);
            int colIdx = Board::SujiToColumnIndex(suji);
            viewLayout[rowIdx][colIdx] = toViewPiece(piece);
        }
    }
    
    return viewLayout;
}
```

**設計上のメリット**:

| 観点 | メリット |
|------|----------|
| **責務の分離** | Model は純粋なドメインロジック、Controller がデータ変換 |
| **依存関係** | Model 層が View 層の DTO に依存しない |
| **テスト容易性** | Model 層を View 層なしで独立してテスト可能 |
| **再利用性** | 同じ Model を異なる View (WPF/WinForms/CLI) で使える |
| **変更の局所化** | View の要求変更は Controller だけで対応可能 |

### Q. Board の内部で `std::optional<Piece>` を使う意味はある？

A. 「`PieceType` に『空』を含めたくない」というポリシーを守るために有効なので、そのまま採用してよい。

- モデル層での方針
  - `Piece` は「存在する駒」だけを表す
  - 盤上の「駒がない」状態は `std::optional<Piece>` の `std::nullopt` で表現する
- 利点
  - `PieceType::None` のような不自然な値を作らなくて済む
  - 「駒がある/ない」が型レベルで区別され、ロジックが明確

View / C++/CLI へは `std::optional` をそのまま出さず、DTO 側でフラットな表現に変換する。

### Q. View に渡す型はどう設計する？ `ViewBoard` は必要？

A. 必須なのは `ViewPiece` のような「1マス分の情報」。盤全体については `std::array` などのエイリアスでもよい。

- モデル層(Board Internal Representation)
  - `using PieceLayout = std::array<std::array<std::optional<Piece>, BoardSize>, BoardSize>;`
- View 向け DTO
  - `struct ViewPiece { bool hasPiece; PlayerSide owner; PieceType pieceType; bool isPromoted; };`
  - `using ViewBoardLayout = std::array<std::array<ViewPiece, BoardSize>, BoardSize>;`
- ポイント
  - 変換対象は「`std::optional<Piece>` → `ViewPiece`」だけ
  - 2次元配列自体は Board と同じ構造をそのまま使えばよく、`ViewBoard` struct は必須ではない
  - 盤に追加情報(ハイライト、選択マスなど)を持たせたくなったら、そのとき `struct ViewBoard` を導入してもよい

### Q. Hand はどう公開する？

A. `Hand` クラス自体ではなく、「各 `PieceType` の枚数一覧」を DTO で公開する。

- モデル層:
  - `class Hand { std::map<PieceType, int> pieces_; ... };`
- View 向け DTO 例:
  - `struct ViewHand { std::array<int, PieceTypeCount> counts; };`
- `GameController` が `Hand` から `ViewHand` を構築して返す:
  - `ViewHand getSenteHandView() const;`
  - `ViewHand getGoteHandView() const;`

こうすることで、UI は単純な配列/構造体だけを扱い、`std::map` や `Hand` 実装に依存しない。

### Q. PieceType 列挙体や Piece クラスはそのまま使える？

A. 層ごとに扱いを分ける。

- モデル層(core)
  - `Piece` クラスと `enum class PieceType` をそのまま使う
  - DTO(`ViewPiece`) では、`Piece` を直接持たせず、`PieceType` や `PlayerSide`、`isPromoted` などの値型だけを持つ
- C++/CLI 層(/clr プロジェクト)
  - 直接 .NET にネイティブの enum やクラスを公開するのではなく、対応するマネージ側 enum / クラスを定義して変換する

例（PieceType のみ抜粋）：

```cpp
// ネイティブ側 (core)
enum class PieceType { Fu, Kyo, Kei, Gin, Kin, Kaku, Hisha, Gyoku };

// C++/CLI 側
public enum class PieceTypeManaged { Fu, Kyo, Kei, Gin, Kin, Kaku, Hisha, Gyoku };

static PieceTypeManaged ToManaged(shoryu::core::PieceType native) {
    return static_cast<PieceTypeManaged>(static_cast<int>(native));
}

static shoryu::core::PieceType ToNative(PieceTypeManaged managed) {
    return static_cast<shoryu::core::PieceType>(static_cast<int>(managed));
}
```

### Q. std::vector や std::optional は C++/CLI で使える？

A. 「ネイティブとして使う」のは問題ないが、マネージ世界に直接公開しない。

- モデル層・ネイティブ DTO では `std::vector`, `std::optional` を自由に使ってよい
- C++/CLI ラッパーで:
  - `std::vector` → `array<T>^` や `List<T>^` へ変換
  - `std::optional<T>` → `nullptr` or 値 / bool+値 などへ変換

設計方針のまとめ

- モデル層(core)
  - ドメイン都合に合わせて `std::optional<Piece>` , `std::map` , `PieceType` などを自然に使う
- View 層 / C++/CLI
  - 単純な DTO (`ViewPiece` , `ViewBoardLayout` , `ViewHand` など) とマネージ enum / クラスを使う
  - 変換ロジックは C++/CLI ラッパー or `GameController` に閉じ込める

これにより、モデル側のきれいな表現(`optional<Piece>` など)と、UI 側の扱いやすさ(配列・単純 struct)の両方を両立できる。