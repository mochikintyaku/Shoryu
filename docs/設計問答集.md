# 設計問答集

## Pieceクラスのデフォルトコンストラクタを定義すべきか
- `Piece` は `PieceType (enum)` と `PlayerSide (enum)` をメンバに持つ。
- 意味のない駒（不正な初期状態）を生成したくないためデフォルト構築を禁じたいという動機。
- しかし、`Piece` をメンバに持つ構造体やクラスの初期化が煩雑になる。
- 結論: デフォルトコンストラクタを用意して運用し、デフォルト値から変更されないことによる不具合が出た段階で再検討する。

## 駒の動きの種類
- 駒を動かす
- 駒を取る
- 駒を成る
- 駒を打つ

## Move構造体の定義配置 (MoveManager.h に含めるべきか)
- 他クラスが `Move` 構造体だけ必要な場合に `MoveManager` まで読み込むのは無駄。
- 方針: まず `Move.h` として独立。後で統合可能なタイミングが来たら再配置を検討。

## std::move 使用判断
- まだ習熟不足と認識。
- （運用メモ）右辺値化の目的: 所有権移動 / コピー回避。不要な場面で付けない癖づけ、戻り値最適化に過信しすぎない。

## vector と array の使い分け
- 要素数が固定でサイズ変更不要 → `std::array`
- 可変長 / 要素追加・削除など柔軟性が必要 → `std::vector`


## テストプロジェクトを含めたときのフォルダ構成

### 設計要件
1. **テストの即時実行性**: アプリ本体とテストを別ソリューションに分けず、同一ソリューション内で管理。
2. **ビルドの明確な分離**: テストプロジェクトのビルドが本体のビルド成果物を汚染しない。
3. **GoogleTest の制約回避**: GoogleTest は Debug/Release 構成のみサポート。独自のビルド構成追加は避ける。

### 採用方針: codetop / testtop プロジェクト方式
- **単一ソリューション構成**: `Shoryu.sln` にすべてのプロジェクトを含める。
- **codetop プロジェクト**: 
  - 空のプロジェクト (ソースコード・エントリポイントなし)。
  - アプリ本体に必要なプロジェクトへの依存関係のみを定義。
  - `codetop` をビルドすると、アプリ本体に必要なプロジェクト群が自動的にビルドされる。
- **testtop プロジェクト**:
  - 空のプロジェクト (ソースコード・エントリポイントなし)。
  - テスト実行に必要なプロジェクトへの依存関係のみを定義。
  - `testtop` をビルドすると、テストプロジェクト群とその依存ライブラリが自動的にビルドされる。

## ShoryuCore クラスから Game クラスへの変更

### 変更の背景
- MVC アーキテクチャの導入に伴い、Model 層の中核クラスの命名を再検討。
- `ShoryuCore` という名前は汎用的すぎて、クラスの責務が不明瞭。

### 検討した候補
1. **GameState** - 最初の候補だったが採用せず
2. **Position** - 将棋エンジンの業界標準だが、既存の `Position(suji, dan)` と名前衝突
3. **Game** - 最終的に採用 ✅

### Game を選んだ理由

#### 理由1: "State" という名前の矛盾
- `GameState` という名前は「不変 (immutable)」を連想させる
- しかし実際のクラスは可変 (mutable) であり、`getBoardMutable()` や `togglePlayer()` などの状態変更メソッドを持つ
- 名前と実装が矛盾している

#### 理由2: 不変にするコストが大きすぎる
- Board クラスだけで約 1600 バイト (9×9×16バイト)
- Hand クラス × 2 も含めると、1つのインスタンスが約 1800 バイト以上
- これを不変にすると、指し手のたびに全体をコピーする必要があり、パフォーマンスが致命的に悪化
- 将棋エンジンでは1秒間に数百万局面を評価するため、コピーコストは許容できない

#### 理由3: Model 層のトップとしての適切な抽象度
- `Game` は「将棋の1局」を表現するクラスとして、ちょうど良い粒度
- Board, Hand, MoveManager などを統合管理する役割
- Model 層の階層構造:
  ```
  Game (将棋の1局全体)
  ├── Board (9×9の盤面)
  ├── Hand (先手の持ち駒)
  ├── Hand (後手の持ち駒)
  └── MoveManager (指し手履歴)
  ```

### Game クラスの責務
- ゲーム全体の状態を統合管理する Model 層の中核クラス
- 盤面、持ち駒、手番、手数などを保持
- `GameController` (Controller 層) から操作される
- C# の View 層には直接公開せず、`GameController` 経由でアクセス

### 設計方針
- **値セマンティクス**: Board, Hand を直接所有 (ポインタではなく値として保持)
- **可変性**: パフォーマンス重視のため、状態は可変として設計
- **MVC パターン**: Model 層として、ビジネスロジックとデータを View/Controller から分離